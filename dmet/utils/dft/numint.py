import numpy as np
from pyscf.dft.numint import _scale_ao, _dot_ao_ao, _rks_gga_wv1

def nr_rksgrad_fxc(ni, mol, grids, xc_code, dm0, dms, relativity=0, hermi=0,
               rho0=None, vxc=None, fxc=None, max_memory=2000, verbose=None):
    '''Contract RKS XC (singlet hessian) kernel matrix derivative with given density matrices

    Adapted from pyscf.dft.numint

    Args:
        ni : an instance of :class:`NumInt`

        mol : an instance of :class:`Mole`

        grids : an instance of :class:`Grids`
            grids.coords and grids.weights are needed for coordinates and weights of meshgrids.
        xc_code : str
            XC functional description.
            See :func:`parse_xc` of pyscf/dft/libxc.py for more details.
        dm0 : 2D array
            Zeroth order density matrix
        dms : 2D array a list of 2D arrays
            First order density matrix or density matrices

    Kwargs:
        hermi : int
            First order density matrix symmetric or not. It also indicates
            whether the matrices in return are symmetric or not.
        max_memory : int or float
            The maximum size of cache to use (in MB).
        rho0 : float array
            Zero-order density (and density derivative for GGA).  Giving kwargs rho0,
            vxc and fxc to improve better performance.
        vxc : float array
            First order XC derivatives
        fxc : float array
            Second order XC derivatives

    Returns:
        nelec, excsum, vmat.
        nelec is the number of electrons generated by numerical integration.
        excsum is the XC functional value.  vmat is the XC potential matrix in
        2D array of shape (nao,nao) where nao is the number of AO functions.

    Examples:

    '''
    xctype = ni._xc_type(xc_code)

    make_rho1, nset, nao = ni._gen_rho_evaluator(mol, dms, hermi)
    if rho0 is None and (xctype != 'LDA' or fxc is None):
        make_rho0 = ni._gen_rho_evaluator(mol, dm0, 1)[0]
    else:
        make_rho0 = None

    def block_loop(ao_deriv):
        p1 = 0
        _rho0 = None
        for ao, mask, weight, coords \
                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory):
            p0, p1 = p1, p1 + weight.size
            if rho0 is not None:
                if xctype == 'LDA':
                    _rho0 = np.asarray(rho0[p0:p1], order='C')
                else:
                    _rho0 = np.asarray(rho0[:,p0:p1], order='C')
            elif make_rho0 is not None:
                if xctype == 'LDA':
                    _rho0 = make_rho0(0, ao[0], mask, xctype)
                else:
                    _rho0 = make_rho0(0, ao, mask, xctype)
            if fxc is None:
                _vxc, _fxc = ni.eval_xc(xc_code, _rho0, spin=0,
                                        relativity=relativity, deriv=2,
                                        verbose=verbose)[1:3]
            else:
                _vxc = [None if x is None else x[p0:p1] for x in vxc]
                _fxc = [None if x is None else x[p0:p1] for x in fxc]

            for i in range(nset):
                if xctype == 'LDA':
                    rho1 = make_rho1(i, ao[0], mask, xctype)
                else:
                    rho1 = make_rho1(i, ao, mask, xctype)
                yield i, _rho0, rho1, ao, mask, weight, _vxc, _fxc

    shls_slice = (0, mol.nbas)
    ao_loc = mol.ao_loc_nr()

    if isinstance(dms, np.ndarray):
        vmat = np.zeros((nset,3,nao,nao), dtype=dms.dtype)
    else:
        vmat = np.zeros((nset,3,nao,nao), dtype=np.result_type(*dms))
    if hermi == 1:
        assert vmat.dtype == np.double

    if xctype == 'LDA':
        ao_deriv = 1
        aow = None
        for i, _rho0, rho1, ao, mask, weight, _vxc, _fxc in block_loop(ao_deriv):
            frr = _fxc[0]
            #:aow = np.einsum('pi,p->pi', ao, weight*frr*rho1, out=aow)
            aow = _scale_ao(ao[0], weight*frr*rho1, out=aow)
            for k in range(3):
                vmat[i][k] += _dot_ao_ao(mol, ao[1+k], aow, mask, shls_slice, ao_loc)

    elif xctype == 'GGA':
        ao_deriv = 2
        aow1 = None
        for i, _rho0, rho1, ao, mask, weight, _vxc, _fxc in block_loop(ao_deriv):
            wv = _rks_gga_wv1(_rho0, rho1, _vxc, _fxc, weight)
            wv[0] *= 2 # wv[0] was halfed in _rks_gga_wv1
            #:aow1 = np.einsum('npi,np->pi', ao[1:4], wv, out=aow)
            aow1 = _scale_ao(ao[:4], wv, out=aow1)
            # ao:
            # XX, XY, XZ = 4, 5, 6
            # YX, YY, YZ = 5, 7, 8
            # ZX, ZY, ZZ = 6, 8, 9
            #:aow2 = einsum('xygi,xg->ygi', ao_hess, wv[1:4])
            aow2 = np.zeros_like(ao[:3])
            aow2[0] += _scale_ao(ao[4], wv[1]) 
            aow2[0] += _scale_ao(ao[5], wv[2])  
            aow2[0] += _scale_ao(ao[6], wv[3])  
            aow2[1] += _scale_ao(ao[5], wv[1])  
            aow2[1] += _scale_ao(ao[7], wv[2])  
            aow2[1] += _scale_ao(ao[8], wv[3])  
            aow2[2] += _scale_ao(ao[6], wv[1])  
            aow2[2] += _scale_ao(ao[8], wv[2])  
            aow2[2] += _scale_ao(ao[9], wv[3])  
            for k in range(3):
                vmat[i][k] += _dot_ao_ao(mol, ao[1+k], aow1, mask, shls_slice, ao_loc)
                vmat[i][k] += _dot_ao_ao(mol, aow2[k], ao[0], mask, shls_slice, ao_loc)

    elif xctype == 'NLC':
        raise NotImplementedError('NLC')

    elif xctype == 'MGGA':
        raise NotImplementedError('MGGA')

    if isinstance(dms, np.ndarray) and dms.ndim == 2:
        vmat = vmat[0]
    return vmat